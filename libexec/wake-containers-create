#!/usr/bin/env ruby

require 'json'
require 'pathname'
require 'tmpdir'
require 'shellwords'
require_relative '../share/wake'
require_relative '../share/wake/parser'
require_relative '../share/wake/root'
require_relative '../share/wake/json_file'
require_relative '../share/wake/run'
require_relative '../share/wake/config'
require_relative '../share/wake/docker_image'
require_relative '../share/wake/git'
require_relative '../share/wake/chdir'
require_relative '../share/wake/tmpdir'
require_relative '../share/wake/dots'

parser = OptsParser.parse do |opts|
  opts.banner = "Usage: wake containers create [options]"

  opts.required :r, :revision, "The git revision to be packaged"
  opts.boolean  :l, :latest,   "Tag this as the latest revision"
  opts.boolean  :f, :force,    "Force a tag for a revision"
  opts.boolean  :p, :push,     "Push to the registry"
end

unless File.exists?("./manifest.json")
  panic! "Must be run in a directory with a manifest.json"
end

git_status, _ = run!("git status")
git_status_last_line = git_status.chomp.lines.last

unless git_status_last_line =~ /^nothing to commit/ || git_status_last_line =~ /^nothing added to commit/
  panic! "You have uncommited changes to your repo, please stash or clean up then try again"
end

hub_organization = WakeConfig.get_or_ask_for("docker.hub.organization")
revision         = Shellwords.escape parser[:revision]
full_sha, _      = run!("git rev-parse --verify #{revision}")
sha              = full_sha[0..8]
images           = [] # so it's in scope at the very end

GitObject = Struct.new(:permissions, :type, :hash, :filepath) do
  def path
    Pathname.new(filepath)
  end

  def blob?
    type == "blob"
  end

  def perm
    permissions[-3..-1]
  end
end

dots do
  git_tree = `git ls-tree --full-tree -r #{full_sha}`.chomp.lines.map(&:split)
  git_objects = git_tree.map { |arr| GitObject.new(*arr) }.select(&:blob?)

  Dir.mktmpdir do |tmpdir|
    Wake.log [:tmpdir, tmpdir]

    # copy in .build-env if it's not checked in
    if File.exists?(".build-env") && !git_objects.any? { |o| o.name == ".build-env" }
      FileUtils.cp(".build-env", tmpdir, preserve: true)
    end

    # copy every file over to the same structure
    git_objects.each do |o|
      nested_dir = File.join(tmpdir, File.dirname(o.filepath))
      FileUtils.mkdir_p(nested_dir)
      content = `git cat-file -p #{o.hash}`
      File.open(o.filepath, "w", o.perm) { |f| f << content }
    end

    chdir(tmpdir) do
      manifest  = JSONFile.new("manifest.json")
      platform  = manifest.require("platform")
      app       = manifest.require("app")
      platform  = manifest.require("platform")
      processes = manifest.require("processes")

      unless File.exists?("Dockerfile") # you can opt into your own Dockerfile
        platform_dockerfile = File.join(WAKE_ROOT, "platforms", "wake", platform, "Dockerfile")

        unless platform_dockerfile || File.exists?("./Dockerfile")
          fail "No Dockerfile found for platform '#{platform}'"
        end

        FileUtils.cp(platform_dockerfile, ".") if File.exists? platform_dockerfile
      end

      processes.each do |process_name, process_info|
        start = process_info["start"]

        image = DockerImage.new(
          app: app,
          process: process_name,
          rev: sha,
          org: hub_organization
        )

        File.open(".dockerignore", "w+") do |f|
          f << ".git/*"
          f << ".processes/*"
        end

        Wake.log "Building #{image.name}..."

        run! "docker build -t #{image.name} --build-arg start='#{start}' --build-arg sha='#{sha}' ."

        if parser[:latest]
          run! "docker tag -f #{image.name} #{image.latest}"
        end

        if parser[:push]
          Wake.log "Pushing images..."

          run! "docker push #{image.name}"
          run! "docker push #{image.latest}" if parser[:latest]
        end

        images << image
      end
    end
  end
end

puts JSON.pretty_generate(images.map(&:to_hash))
