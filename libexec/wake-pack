#!/usr/bin/env ruby

require_relative '../share/wake/parser'
require_relative '../share/wake/root'
require_relative '../share/wake/json_file'
require_relative '../share/wake/run'
require_relative '../share/wake/config'
require_relative '../share/wake/dockerfile'
require_relative '../share/wake/docker_image'
require 'tmpdir'

parser = OptsParser.parse do |opts|
  opts.banner = "Usage: wake seed [options]"

  opts.required :r, :revision, "The git revision to be packaged"
  opts.boolean  :f, :force,    "Force a tag for a revision"
  opts.boolean  :p, :push,     "Push to the registry"
  opts.boolean  :v, :verbose,  "Run verbosely"
end

manifest = JSONFile.new("manifest.json")
platform = manifest.require("platform")
app      = manifest.require("app")
sha      = parser[:revision]

hub_organization = WakeConfig.get_or_ask_for("docker.hub.organization")

platform = manifest.require("platform")
dockerfile_compile = File.join(WAKE_ROOT, "platforms", "wake", platform, "Dockerfile-compile.erb")

processes = manifest.require("processes")

# get all the files git knows about
git_files = `git ls-files`.lines.map(&:chomp)

# get all the files in any submodule
path_regex = /\A\s*path = (\w+)\s*\z/

submodules = if File.exists?(".gitmodules")
  File.read(".gitmodules").lines.map(&:chomp)
    .grep(path_regex) { |l| l.match(path_regex)[1] }
else
  []
end

# merge the submodules and the regular files
submodules.each do |s|
  git_files.delete(s)
  Dir.chdir(s) do
    git_files.concat `git ls-files`.lines.map(&:chomp)
      .map { |l| File.join(s, l) }
  end
end

Dir.mktmpdir do |tmpdir|
  # p tmpdir

  # copy every file over to the same structure
  git_files.each do |f|
    nested_dir = File.join(tmpdir, File.dirname(f))
    FileUtils.mkdir_p(nested_dir)
    FileUtils.cp(f, nested_dir, preserve: true)
  end

  # go to the tmpdir
  Dir.chdir tmpdir

  processes.each do |process_name, process_info|
    start = process_info["start"]
    folder = ".processes/#{process_name}"

    dockerfile = Dockerfile.new(
      path: dockerfile_compile,
      sha: sha,
      start: start,
      target: folder
    )

    image = DockerImage.new(
      app: app,
      process: process_name,
      rev: sha,
      org: hub_organization
    )

    dockerfile.write!

    File.open(".dockerignore", "w") do |f|
      f << ".git/*"
      f << ".processes/*"
    end

    puts "Building #{image.name}..."

    run! "docker build -t #{image.name} -f #{dockerfile.local_path} .", parser[:verbose]

    if parser[:push]
      run! "docker push #{image.name}", parser[:verbose]
    end
  end
end

