#!/usr/bin/env ruby

require 'securerandom'
require 'shellwords'
require_relative '../share/wake/parser'
require_relative '../share/wake/config'
require_relative '../share/wake/azure'

parser = OptsParser.parse do |opts|
  opts.banner = <<-EOF
Usage: wake vmi create [options]

NOTE: Requires an ssh public key.
EOF

  opts.boolean :v, :verbose,  "Run verbosely"
end

cluster_name           = "Plum-EastUS" # TODO: fetch this from wake config
cluster_location       = "eastus" # TODO: fetch this from wake config
tenant_id              = WakeConfig.get_or_ask_for("azure.account.tenant_id")
client_id              = WakeConfig.get_or_ask_for("azure.account.client_id")
secret                 = WakeConfig.get_or_ask_for("azure.account.secret")
subscription_id        = WakeConfig.get_or_ask_for("azure.account.subscription_id")
public_key_path        = File.expand_path(WakeConfig.get_or_ask_for("ssh.public_key.path"))

random_name            = SecureRandom.hex(8)
computer_name          = "#{cluster_name}-host-#{random_name}"

p [:random, random_name, computer_name]

subnet_name            = "#{cluster_name}-subnet"
vnet_name              = "#{cluster_name}-vnet"
os_disk_name           = "os-#{random_name}"
network_interface_name = "ni-#{random_name}"
ip_configuration_name  = "ip-#{random_name}"
domain_name            = "dn-#{random_name}"
public_ip_address_name = ip_configuration_name
resource_group_name    = cluster_name # TODO: fetch this from wake config
storage_account_name   = cluster_name # TODO: fetch this from wake config
base_storage_uri       = "https://#{storage_account_name}.blob.core.windows.net/#{random_name}"
vhd_uri                = "#{base_storage_uri}/#{os_disk_name}.vhd"

unless File.exists?(public_key_path)
  raise "Cannot find file '#{public_key_path}'"
end

escaped_path = Shellwords.escape(public_key_path)
public_key = `ssh-keygen -f #{escaped_path} -e -m pem`.chomp

unless $?.success?
  raise "Failed to convert ssh public key to pem format"
end

random_password = SecureRandom.urlsafe_base64(32).tap do |b|
  puts "Random machine password: #{b}" # if parser[:verbose]
end

token_provider = MsRestAzure::ApplicationTokenProvider.new(tenant_id, client_id, secret)
credentials = MsRest::TokenCredentials.new(token_provider)

compute_client = ComputeManagementClient.new(credentials).tap do |c|
  c.subscription_id = subscription_id
end

network_client = NetworkResourceProviderClient.new(credentials).tap do |c|
  c.subscription_id = subscription_id
end

props = VirtualMachineProperties.new

linux_config = LinuxConfiguration.new.tap do |l|
  l.disable_password_authentication = false
  l.ssh = SshConfiguration.new.tap do |ss|
    key = SshPublicKey.new.tap { |k| k.key_data = public_key }
    ss.public_keys = [key]
  end
end

props.os_profile = OSProfile.new.tap do |o|
  o.computer_name = computer_name
  o.admin_username = 'awake'
  o.admin_password = random_password
  o.linux_configuration = linux_config
  o.secrets = []
end

props.hardware_profile = HardwareProfile.new.tap do |h|
  h.vm_size = 'Standard_A3'
end

props.storage_profile = StorageProfile.new.tap do |s|
  s.image_reference = ImageReference.new.tap do |i|
    i.publisher = "Canonical"
    i.offer = "UbuntuServer"
    i.sku = "14.04.2-LTS"
    i.version = "14.04.201503090"
  end

  s.os_disk = OSDisk.new.tap do |o|
    o.caching = 'None'
    o.create_option = 'fromImage'
    o.name = os_disk_name
    o.vhd = VirtualHardDisk.new.tap do |v|
      v.uri = vhd_uri
    end
  end
end

public_ip_address_params = PublicIpAddress.new.tap do |i|
  i.location = cluster_location

  i.properties = PublicIpAddressPropertiesFormat.new.tap do |pi|
    pi.public_ipallocation_method = 'Dynamic'

    pi.dns_settings = PublicIpAddressDnsSettings.new.tap do |pia|
      pia.domain_name_label = domain_name
    end
  end
end

def resolve(thing)
  if thing.respond_to?(:value!)
    thing.value!.body
  else
    thing
  end
end

p ["creating public ip", public_ip_address_params]

public_ip_address_result = network_client.public_ip_addresses.create_or_update(resource_group_name, public_ip_address_name, public_ip_address_params)
public_ip_address = resolve(public_ip_address_result)

subnet_params = Subnet.new.tap do |s|
  s.name = subnet_name

  s.properties = SubnetPropertiesFormat.new.tap do |spf|
    spf.address_prefix = '10.0.2.0/24'
  end
end

virtual_network_params = VirtualNetwork.new.tap do |v|
  v.location = cluster_location

  v.properties = VirtualNetworkPropertiesFormat.new.tap do |vp|
    vp.address_space = AddressSpace.new.tap do |a|
      a.address_prefixes = ['10.0.0.0/16']
    end

    vp.dhcp_options = DhcpOptions.new.tap do |d|
      d.dns_servers = %w(10.1.1.1 10.1.2.4)
    end

    vp.subnets = [subnet_params]
  end
end

p ["creating virtual network", virtual_network_params]

virtual_network_result = network_client.virtual_networks.create_or_update(resource_group_name, vnet_name, virtual_network_params)
virtual_network = resolve(virtual_network_result)

p ["creating subnet", subnet_params]

subnet_result = network_client.subnets.create_or_update(resource_group_name, vnet_name, subnet_name, subnet_params)
subnet = resolve(subnet_result)

network_interface = NetworkInterface.new.tap do |ni|
  ni.location = cluster_location
  ni.name     = network_interface_name

  ni.properties = NetworkInterfacePropertiesFormat.new.tap do |nipf|
    ip_configuration = NetworkInterfaceIpConfiguration.new.tap do |niic|
      niic.name = ip_configuration_name

      niic.properties = NetworkInterfaceIpConfigurationPropertiesFormat.new.tap do |niicpf|
        niicpf.private_ipallocation_method = 'Dynamic'
        niicpf.public_ipaddress = public_ip_address
        niicpf.subnet = subnet
      end
    end

    nipf.ip_configurations = [ip_configuration]
  end
end

props.network_profile = NetworkProfile.new.tap do |n|
  n.network_interfaces = [network_interface]
end

params = VirtualMachine.new.tap do |v|
  v.type = 'Microsoft.Compute/virtualMachines'
  v.properties = props
  v.location = cluster_location
end

p ["creating a new virtual machine"]

promise = compute_client.virtual_machines.create_or_update(resource_group_name, computer_name, params)

result = resolve(promise)

p [:result, result]

